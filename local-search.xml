<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一学习就犯困，怎么破解</title>
    <link href="/2022/10/29/%E4%B8%80%E5%AD%A6%E4%B9%A0%E5%B0%B1%E7%8A%AF%E5%9B%B0%EF%BC%8C%E6%80%8E%E4%B9%88%E7%A0%B4%E8%A7%A3/"/>
    <url>/2022/10/29/%E4%B8%80%E5%AD%A6%E4%B9%A0%E5%B0%B1%E7%8A%AF%E5%9B%B0%EF%BC%8C%E6%80%8E%E4%B9%88%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一学习就犯困是怎么回事？"><a href="#一学习就犯困是怎么回事？" class="headerlink" title="一学习就犯困是怎么回事？"></a>一学习就犯困是怎么回事？</h1><hr><p>  为什么一读书就犯困?很多人就会发现一个现象，当让你去读书看书，或者是记一些东西的时候，一下子就会想要犯困睡觉没有精神，这也让很多需要读书，记一些东西的人感到苦恼，那么下面就为大家分析原因。</p><p>　　从<a href="http://xl.wenkang.cn/">心理</a>学的角度分析，这是一种条件反射所形成的不良习惯。睡眠本来是与看书活动无关的人的本能行为，但由于与无关刺激建立了联系，就形成了相应的条件反射。如人在疲劳动情况下，仍然坚持看书学习，当拿起书时，又抵制不住疲劳的侵袭，便想抛书睡觉，但又觉得不学不看不行而勉强支持，多次反复以后学习与睡觉两种无关的活动就联系起来了，经过不断强化，这种联系逐渐固定下来，以后看书便成了瞌睡的诱发因素，只要拿起书便想睡觉。当然，有些人并不是因疲劳而引起，也可能因对书不感兴趣或对学习反感等形成这种抑制性条件反射。所以，要克服这种毛病，必须消除抑制性条件反射，建立兴奋性条件反射。那么，怎样建立这种反射呢?</p><p>　　要培养浓厚的学习兴趣是推动前进的原动力。它对于主体来说，总是带有快乐、欢喜和满意的情感体验。人一旦对看书学习产生了兴趣，就会自觉积极地投入学习活动，激发学习的动力，从而改变抑制性条件反射。有了兴趣，就会促进兴趣，以此形成良性循环。而良性循环的形成也就是兴奋性条件反射的建立。</p><p>　　注意学习方式为了避免产生抑制性条件反射，学习要时要注意方式方法，科学用脑，合理安排学习时间，做到劳逸结合，一般情况下要做到：</p><p>　　<strong>疲劳困倦时不要看书</strong></p><p>　　人体机能活动具有一定限度，活动超过限度，大脑皮层就会自动进入抑制状态。这就是所谓的保护性抑制。因此，自己感到疲劳困倦时，就不要勉强支持看书，尤其是不要“开夜车“看书，以避免形成不良习惯。</p><p>　　<strong>饭后不要马上看书</strong></p><p>　　人进食后，消化系统的活动量加大，大脑血液流量相对减少，中枢神经主要控制消化系统，而对其它部位处于抑制状态，如果此时看书，不仅效果差，而且易形成抑制性条件反射。</p><p>　　<strong>睡觉前最好不要看书</strong></p><p>　　有些人习惯躺在床上看书，把看书当作催眠，这种习惯最易形成抑制性条件反射。</p><p>　　通过上面内容分析，我们可以看得出来，从<a href="http://xl.wenkang.cn/">心理健康</a>的角度来讲，看书就想睡觉，很多时候是一种条件反射形成的习惯，当然这种习惯是不好的，尤其是对正在，学习或处于升学考试的人来讲。</p><p>转载：<a href="https://envirsci-stu.ahnu.edu.cn/info/1011/1355.htm">https://envirsci-stu.ahnu.edu.cn/info/1011/1355.htm</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式和单一原则</title>
    <link href="/2022/10/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8D%95%E4%B8%80%E5%8E%9F%E5%88%99/"/>
    <url>/2022/10/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8D%95%E4%B8%80%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h3 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h3><p>编写软件过程中，程序员面临着来自 <strong>耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性</strong> 等多方面的 挑战，设计模式是为了让程序(软件)，具有更好</p><ol><li>代码重用性 (即：相同功能的代码，不用多次编写) </li><li>可读性 (即：编程规范性, 便于其他程序员的阅读和理解) </li><li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)  </li><li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响) </li><li>使程序呈现高内聚，低耦合的特性</li></ol><h3 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h3><p>设计模式原则，其实就是<strong>程序员在编程时，应当遵守的原则</strong>，也是各种<strong>设计模式的基础</strong>(即：<strong>设计模式为什么 这样设计的依据</strong>)</p><h4 id="设计模式常用的七大原则有"><a href="#设计模式常用的七大原则有" class="headerlink" title="设计模式常用的七大原则有:"></a>设计模式常用的七大原则有:</h4><ul><li><p>单一职责原则</p></li><li><p>接口隔离原则 </p></li><li><p>依赖倒转(倒置)原则</p></li><li><p>里氏替换原则</p></li><li><p>开闭原则</p></li><li><p>迪米特法则</p></li><li><p>合成复用原则</p></li></ul><h4 id="单一职责原则基本介绍"><a href="#单一职责原则基本介绍" class="headerlink" title="单一职责原则基本介绍"></a>单一职责原则基本介绍</h4><p>​        对类来说的，<strong>即一个类应该只负责一项职责</strong>。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更 而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2</p><p>案例（代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.principle.singleresponsibility;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleResponsibility1</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Vehicle</span> <span class="hljs-variable">vehicle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>();<br>vehicle.run(<span class="hljs-string">&quot;摩托车&quot;</span>);<br>vehicle.run(<span class="hljs-string">&quot;汽车&quot;</span>);<br>vehicle.run(<span class="hljs-string">&quot;飞机&quot;</span>);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String vehicle)</span> &#123;<br>System.out.println(vehicle + <span class="hljs-string">&quot; 在公路上运行....&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/chaozuoxitong123/tuchuang/main/img202210281705454.png" alt="image-20221002212252092"></p><p>这个代码违反了单一职责原则，不是优秀的代码。</p><p>改进1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.principle.singleresponsibility;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleResponsibility2</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">RoadVehicle</span> <span class="hljs-variable">roadVehicle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoadVehicle</span>();<br>roadVehicle.run(<span class="hljs-string">&quot;摩托车&quot;</span>);<br>roadVehicle.run(<span class="hljs-string">&quot;汽车&quot;</span>);<br><br><span class="hljs-type">AirVehicle</span> <span class="hljs-variable">airVehicle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AirVehicle</span>();<br><br>airVehicle.run(<span class="hljs-string">&quot;飞机&quot;</span>);<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RoadVehicle</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String vehicle)</span> &#123;<br>System.out.println(vehicle + <span class="hljs-string">&quot;公路运行&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AirVehicle</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String vehicle)</span> &#123;<br>System.out.println(vehicle + <span class="hljs-string">&quot;天空运行&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaterVehicle</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String vehicle)</span> &#123;<br>System.out.println(vehicle + <span class="hljs-string">&quot;水中运行&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/chaozuoxitong123/tuchuang/main/img202210281705955.png" alt="image-20221002212540659"></p><p>优点：</p><ul><li>遵守了单一职责原则</li></ul><p>缺点：</p><ul><li>这样做的改动很大，将类分解，同时修改客户端</li></ul><p>改进2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.principle.singleresponsibility;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleResponsibility3</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Vehicle2</span> <span class="hljs-variable">vehicle2</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle2</span>();<br>vehicle2.run(<span class="hljs-string">&quot;汽车&quot;</span>);<br>vehicle2.runWater(<span class="hljs-string">&quot;轮船&quot;</span>);<br>vehicle2.runAir(<span class="hljs-string">&quot;飞机&quot;</span>);<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String vehicle)</span> &#123;<br>System.out.println(vehicle + <span class="hljs-string">&quot; 在公路上运行....&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runAir</span><span class="hljs-params">(String vehicle)</span> &#123;<br>System.out.println(vehicle + <span class="hljs-string">&quot; 在天空上运行....&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWater</span><span class="hljs-params">(String vehicle)</span> &#123;<br>System.out.println(vehicle + <span class="hljs-string">&quot; 在水中行....&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/chaozuoxitong123/tuchuang/main/img202210281705117.png" alt="image-20221002212943838"></p><p>优点：</p><ul><li>遵守了单一职责原则，而且这种修改方法没有对原来的类做大的修改，只是增加方法，这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</li></ul><h3 id="单一职责原则注意事项和细节"><a href="#单一职责原则注意事项和细节" class="headerlink" title="单一职责原则注意事项和细节"></a>单一职责原则注意事项和细节</h3><ul><li><p>降低类的复杂度，一个类只负责一项职责。</p></li><li><p>提高类的可读性，可维护性</p></li><li><p>降低变更引起的风险</p></li><li><p>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中 方法数量足够少，可以在方法级别保持单一职责原则，上面第三个代码就是这种情况</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树的节点查找和删除</title>
    <link href="/2022/10/28/%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%9F%A5%E6%89%BE%E5%92%8C%E5%88%A0%E9%99%A4/"/>
    <url>/2022/10/28/%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%9F%A5%E6%89%BE%E5%92%8C%E5%88%A0%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树查找指定的节点"><a href="#二叉树查找指定的节点" class="headerlink" title="二叉树查找指定的节点"></a>二叉树查找指定的节点</h3><h4 id="前序查找的思路"><a href="#前序查找的思路" class="headerlink" title="前序查找的思路"></a>前序查找的思路</h4><blockquote><p>1.先判断当前节点的no是否等于要查找的</p><p>2.如果是相等，则返回当前节点</p><p>3.如果不等，则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找</p><p>4.如果左递归前序查找，找到节点，则返回，否继续判断，当前的节点的右子节点是否为空，如果不为空，则继续向右递归前序查找。</p></blockquote><h4 id="中序查找思路"><a href="#中序查找思路" class="headerlink" title="中序查找思路"></a>中序查找思路</h4><blockquote><p>1.判断当前节点的左子节点是否为空，如果不为空，则递归中序查找</p><p>2.如果找到，则返回，如果没有找到，就和当前节点比较，如果是则返回当前节点，否则继续进行右递归的中序查找</p><p>3.如果右递归中序查找，找到就返回，否则返回null</p></blockquote><h4 id="后序查找思路"><a href="#后序查找思路" class="headerlink" title="后序查找思路"></a>后序查找思路</h4><blockquote><p>1.判断当前节点的左子节点是否为空，如果不为空，则递归后序查找</p><p>2.如果找到，就返回，如果没有找到，就判断当前节点的右子节点是否为空，如果不为空，则右递归进行后序查找，如果找到，就返回</p><p>3.就和当前节点进行比较，如果是则返回，否则返回null</p></blockquote><p>要求</p><blockquote><p>1.请编写前序查找，中序查找和后序查找的方法。</p><p>2.并分别使用三种查找方式，查找 heroNO = 5 的节点</p><p>3.并分析各种查找方式，分别比较了多少次</p></blockquote><p>代码实现：</p><p>先创建HeroNode 结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroNode</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> no;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> HeroNode left; <span class="hljs-comment">//默认null</span><br><span class="hljs-keyword">private</span> HeroNode right; <span class="hljs-comment">//默认null</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HeroNode</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name)</span> &#123;<br><span class="hljs-built_in">this</span>.no = no;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> no;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNo</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br><span class="hljs-built_in">this</span>.no = no;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">getLeft</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLeft</span><span class="hljs-params">(HeroNode left)</span> &#123;<br><span class="hljs-built_in">this</span>.left = left;<br>&#125;<br><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">getRight</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> right;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRight</span><span class="hljs-params">(HeroNode right)</span> &#123;<br><span class="hljs-built_in">this</span>.right = right;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HeroNode [no=&quot;</span> + no + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br>    <span class="hljs-comment">//前序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//先输出父结点</span><br><span class="hljs-comment">//递归向左子树前序遍历</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.left.preOrder();<br>&#125;<br><span class="hljs-comment">//递归向右子树前序遍历</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.right.preOrder();<br>&#125;<br>&#125;<br><span class="hljs-comment">//前序遍历查找</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> no 查找no</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果找到就返回该Node ,如果没有找到返回 null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">preOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;进入前序遍历&quot;</span>);<br><span class="hljs-comment">//比较当前结点是不是</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.no == no) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><span class="hljs-comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span><br><span class="hljs-comment">//2.如果左递归前序查找，找到结点，则返回</span><br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">resNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;<br>resNode = <span class="hljs-built_in">this</span>.left.preOrderSearch(no);<br>&#125;<br><span class="hljs-keyword">if</span>(resNode != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//说明我们左子树找到</span><br><span class="hljs-keyword">return</span> resNode;<br>&#125;<br><span class="hljs-comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span><br><span class="hljs-comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;<br>resNode = <span class="hljs-built_in">this</span>.right.preOrderSearch(no);<br>&#125;<br><span class="hljs-keyword">return</span> resNode;<br>&#125;<br><br><span class="hljs-comment">//中序遍历查找</span><br><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">infixOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br><span class="hljs-comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span><br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">resNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;<br>resNode = <span class="hljs-built_in">this</span>.left.infixOrderSearch(no);<br>&#125;<br><span class="hljs-keyword">if</span>(resNode != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> resNode;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;进入中序查找&quot;</span>);<br><span class="hljs-comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.no == no) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><span class="hljs-comment">//否则继续进行右递归的中序查找</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;<br>resNode = <span class="hljs-built_in">this</span>.right.infixOrderSearch(no);<br>&#125;<br><span class="hljs-keyword">return</span> resNode;<br><br>&#125;<br><br><span class="hljs-comment">//后序遍历查找</span><br><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">postOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br><br><span class="hljs-comment">//判断当前结点的左子节点是否为空，如果不为空，则递归后序查找</span><br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">resNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;<br>resNode = <span class="hljs-built_in">this</span>.left.postOrderSearch(no);<br>&#125;<br><span class="hljs-keyword">if</span>(resNode != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//说明在左子树找到</span><br><span class="hljs-keyword">return</span> resNode;<br>&#125;<br><br><span class="hljs-comment">//如果左子树没有找到，则向右子树递归进行后序遍历查找</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;<br>resNode = <span class="hljs-built_in">this</span>.right.postOrderSearch(no);<br>&#125;<br><span class="hljs-keyword">if</span>(resNode != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> resNode;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;进入后序查找&quot;</span>);<br><span class="hljs-comment">//如果左右子树都没有找到，就比较当前结点是不是</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.no == no) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><span class="hljs-keyword">return</span> resNode;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>定义BinaryTree 二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span> &#123;<br><span class="hljs-keyword">private</span> HeroNode root;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoot</span><span class="hljs-params">(HeroNode root)</span> &#123;<br><span class="hljs-built_in">this</span>.root = root;<br>&#125;<br><br><span class="hljs-comment">//前序遍历查找</span><br><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">preOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br><span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> root.preOrderSearch(no);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//中序遍历查找</span><br><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">infixOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br><span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> root.infixOrderSearch(no);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//后序遍历查找</span><br><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">postOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br><span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.root.postOrderSearch(no);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTreeDemo</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//先需要创建一颗二叉树</span><br><span class="hljs-type">BinaryTree</span> <span class="hljs-variable">binaryTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryTree</span>();<br><span class="hljs-comment">//创建需要的结点</span><br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;宋江&quot;</span>);<br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;吴用&quot;</span>);<br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">node3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;卢俊义&quot;</span>);<br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">node4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;林冲&quot;</span>);<br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">node5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;关胜&quot;</span>);<br><br><span class="hljs-comment">//说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span><br>root.setLeft(node2);<br>root.setRight(node3);<br>node3.setRight(node4);<br>node3.setLeft(node5);<br>binaryTree.setRoot(root);<br><br><span class="hljs-comment">// 前序遍历</span><br><span class="hljs-comment">// 前序遍历的次数 ：4</span><br>System.out.println(<span class="hljs-string">&quot;前序遍历方式~~~&quot;</span>);<br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">resNode</span> <span class="hljs-operator">=</span> binaryTree.preOrderSearch(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">if</span> (resNode != <span class="hljs-literal">null</span>) &#123;<br>System.out.printf(<span class="hljs-string">&quot;找到了，信息为 no=%d name=%s&quot;</span>, resNode.getNo(), resNode.getName());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.printf(<span class="hljs-string">&quot;没有找到 no = %d 的英雄&quot;</span>, <span class="hljs-number">5</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">// 中序遍历查找</span><br><span class="hljs-comment">// 中序遍历3次</span><br><span class="hljs-comment">System.out.println(&quot;中序遍历方式~~~&quot;);</span><br><span class="hljs-comment">HeroNode resNode = binaryTree.infixOrderSearch(5);</span><br><span class="hljs-comment">if (resNode != null) &#123;</span><br><span class="hljs-comment">System.out.printf(&quot;找到了，信息为 no=%d name=%s&quot;, resNode.getNo(), resNode.getName());</span><br><span class="hljs-comment">&#125; else &#123;</span><br><span class="hljs-comment">System.out.printf(&quot;没有找到 no = %d 的英雄&quot;, 5);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">// 后序遍历查找</span><br><span class="hljs-comment">// 后序遍历查找的次数 2次</span><br><span class="hljs-comment">System.out.println(&quot;后序遍历方式~~~&quot;);</span><br><span class="hljs-comment">HeroNode resNode = binaryTree.postOrderSearch(5);</span><br><span class="hljs-comment">if (resNode != null) &#123;</span><br><span class="hljs-comment">System.out.printf(&quot;找到了，信息为 no=%d name=%s&quot;, resNode.getNo(), resNode.getName());</span><br><span class="hljs-comment">&#125; else &#123;</span><br><span class="hljs-comment">System.out.printf(&quot;没有找到 no = %d 的英雄&quot;, 5);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如图：</p><p>前序遍历：</p><p>​    <img src="https://raw.githubusercontent.com/chaozuoxitong123/tuchuang/main/img202210281702975.png" alt="image-20220923205720568"></p><p>中序遍历：</p><p><img src="E:\workspaces\Typora\树的节点查找和删除.assets\image-20220923205804856.png" alt="image-20220923205804856"></p><p>后序遍历：</p><p><img src="https://raw.githubusercontent.com/chaozuoxitong123/tuchuang/main/img202210281702923.png" alt="image-20220923205905104"></p><h3 id="二叉树删除指定的节点"><a href="#二叉树删除指定的节点" class="headerlink" title="二叉树删除指定的节点"></a>二叉树删除指定的节点</h3><p>要求</p><blockquote><p>1.如果删除的节点是叶子节点，则删除该节点</p><p>2.如果删除的节点是非叶子节点，则删除该子树.</p><p>3.测试，删除掉 5 号叶子节点 </p></blockquote><blockquote><p>思路：</p><p>1.考虑如果树是空树root,如果只有一个root节点，则等价将二叉树置空</p><p>2.因为我们的二叉树是单向的，所以我们是判断当前节点的子节点是否是需要删除节点，而不能去判断当前这个节点是不是需要删除节点。</p><p>3.如果当前节点的左子节点不为空，并且左子节点就是要删除节点，就将this.left=null;</p><p>并且就返回（结束递归删除）</p><p>4.如果当前节点的右子节点不为空，并且右子节点就是要删除节点，就将this.right=null;</p><p>并且就返回（结束递归删除）</p><p>5.如果3，4步没有删除节点，那么我们就需要向左子树进行递归删除</p><p>6.如果第5步也没有删除节点，则应当向右子树进行递归删除。</p></blockquote><p>代码实现：</p><p>//HeroNode 类增加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递归删除结点</span><br><span class="hljs-comment">//1.如果删除的节点是叶子节点，则删除该节点</span><br><span class="hljs-comment">//2.如果删除的节点是非叶子节点，则删除该子树</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delNode</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br><br><span class="hljs-comment">//思路</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</span><br><span class="hljs-comment">2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span><br><span class="hljs-comment">3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span><br><span class="hljs-comment">4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span><br><span class="hljs-comment">5.  如果第4步也没有删除结点，则应当向右子树进行递归删除.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.left.no == no) &#123;<br><span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.right.no == no) &#123;<br><span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//4.我们就需要向左子树进行递归删除</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.left.delNode(no);<br>&#125;<br><span class="hljs-comment">//5.则应当向右子树进行递归删除</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.right.delNode(no);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>//在 BinaryTree 类增加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除结点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delNode</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br><span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span><br><span class="hljs-keyword">if</span>(root.getNo() == no) &#123;<br>root = <span class="hljs-literal">null</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//递归删除</span><br>root.delNode(no);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;空树，不能删除~&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>//在 BinaryTreeDemo 类增加测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试一把删除结点</span><br>System.out.println(<span class="hljs-string">&quot;删除前,前序遍历&quot;</span>);<br>binaryTree.preOrder(); <span class="hljs-comment">//  1,2,3,5,4</span><br>binaryTree.delNode(<span class="hljs-number">5</span>);<br><span class="hljs-comment">//binaryTree.delNode(3);</span><br>System.out.println(<span class="hljs-string">&quot;删除后，前序遍历&quot;</span>);<br>binaryTree.preOrder(); <span class="hljs-comment">// 1,2,3,4</span><br></code></pre></td></tr></table></figure><p>代码运行如图：</p><p><img src="https://raw.githubusercontent.com/chaozuoxitong123/tuchuang/main/img202210281702389.png" alt="image-20220923213515000"></p><p>这篇博客是我在B站看韩顺平老师数据结构和算法的课时的笔记，记录一下，防止忘记，也希望能帮助各位朋友。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>顺序存储二叉树</title>
    <link href="/2022/10/28/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/10/28/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="顺序存储二叉树的概念"><a href="#顺序存储二叉树的概念" class="headerlink" title="顺序存储二叉树的概念"></a>顺序存储二叉树的概念</h3><blockquote><p>从数据存储来看，数组存储方式和树的存储方式可以相互转换，即<strong>数组可以转换成树</strong>，<strong>树也可以转换成数组</strong>， 看下面的示意图。</p></blockquote><p><img src="https://raw.githubusercontent.com/chaozuoxitong123/tuchuang/main/img202210281701504.png" alt="image-20220924095635923"></p><blockquote><p>要求：</p><ol><li>右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6] </li><li>要求在遍历数组 arr 时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历</li></ol></blockquote><blockquote><p>顺序存储二叉树的特点:</p><pre><code class="hljs">1. 顺序二叉树通常只考虑完全二叉树1.  第 n 个元素的左子节点为 2 * n + 1 1.  第 n 个元素的右子节点为 2 * n + 2 1.  第 n 个元素的父节点为 (n-1) / 2 1.  n : 表示二叉树中的第几个元素(按 0 开始编号如图所示)</code></pre></blockquote><h3 id="顺序存储二叉树遍历"><a href="#顺序存储二叉树遍历" class="headerlink" title="顺序存储二叉树遍历"></a>顺序存储二叉树遍历</h3><blockquote><p>需求: 给你一个数组 {1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为1,2,4,5,3,6,7</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.tree;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrBinaryTreeDemo</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> &#125;;<br><span class="hljs-comment">//创建一个 ArrBinaryTree</span><br><span class="hljs-type">ArrBinaryTree</span> <span class="hljs-variable">arrBinaryTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrBinaryTree</span>(arr);<br>arrBinaryTree.preOrder(); <span class="hljs-comment">// 1,2,4,5,3,6,7</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//编写一个ArrayBinaryTree, 实现顺序存储二叉树遍历</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrBinaryTree</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arr;<span class="hljs-comment">//存储数据结点的数组</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-built_in">this</span>.arr = arr;<br>&#125;<br><br><span class="hljs-comment">//重载preOrder</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">this</span>.preOrder(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//编写一个方法，完成顺序存储二叉树的前序遍历</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index 数组的下标 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br><span class="hljs-comment">//如果数组为空，或者 arr.length = 0</span><br><span class="hljs-keyword">if</span>(arr == <span class="hljs-literal">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;数组为空，不能按照二叉树的前序遍历&quot;</span>);<br>&#125;<br><span class="hljs-comment">//输出当前这个元素</span><br>System.out.println(arr[index]); <br><span class="hljs-comment">//向左递归遍历</span><br><span class="hljs-keyword">if</span>((index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &lt; arr.length) &#123;<br>preOrder(<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span> );<br>&#125;<br><span class="hljs-comment">//向右递归遍历</span><br><span class="hljs-keyword">if</span>((index * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>) &lt; arr.length) &#123;<br>preOrder(<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<img src="https://raw.githubusercontent.com/chaozuoxitong123/tuchuang/main/img202210281701266.png" alt="image-20220926165138064"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最长公共前缀</title>
    <link href="/2022/10/28/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <url>/2022/10/28/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flight&quot;</span>]<br>输出：<span class="hljs-string">&quot;fl&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;racecar&quot;</span>,<span class="hljs-string">&quot;car&quot;</span>]<br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：输入不存在公共前缀。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><blockquote><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> 仅由小写英文字母组成</li></ul></blockquote><p>思路分析：如果是个空数组，直接返回空字符串。以第一个字符串作为标准，分别与后面的每个字符串进行比较。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">//题目链接：https://leetcode.cn/problems/longest-common-prefix/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T14</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 测试一把</span><br><span class="hljs-type">Solution</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br>String[] str = &#123; <span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flowight&quot;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> solution.longestCommonPrefix(str);<br>System.out.println(string);<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br><span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果是个空数组，直接返回空字符串</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>];<span class="hljs-comment">// 先把数组第一个字符串作为标准</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; strs.length; i++) &#123;<span class="hljs-comment">// 分别与后面的字符串进行比较</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  int j = 0; =&gt; 这个写在外面是为了后面能够得到j的值,</span><br><span class="hljs-comment"> *  从而得到在哪里有公共前缀，如果写在里面，一旦跳出for循环，将无法得到</span><br><span class="hljs-comment"> *  公共前缀的坐标</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (; j &lt; ans.length() &amp;&amp; j &lt; strs[i].length(); j++) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * j &lt; ans.length() &amp;&amp; j &lt; strs[i].length() =&gt; 比较的时候，总得</span><br><span class="hljs-comment"> * 在两个要比较的字符串的长度内进行比较，更准确的说，应该是在</span><br><span class="hljs-comment"> * 两个字符串中的较短的字符串长度内进行比较</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">if</span> (ans.charAt(j) != strs[i].charAt(j)) &#123;<br><span class="hljs-comment">//只要发现有一个字符不匹配，则立即跳出循环</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>ans = ans.substring(<span class="hljs-number">0</span>, j);<span class="hljs-comment">//得到公共前缀</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * substring(int beginIndex, int endIndex)方法的作用：</span><br><span class="hljs-comment"> * 返回一个新字符串，它是此字符串的一个子字符串。</span><br><span class="hljs-comment"> * 该子字符串从指定的 beginIndex 处开始，直到索引 endIndex - 1 处的字符。</span><br><span class="hljs-comment"> * 因此，该子字符串的长度为 endIndex-beginIndex。 </span><br><span class="hljs-comment">示例： </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> &quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot;</span><br><span class="hljs-comment"> &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (ans.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<span class="hljs-comment">//如果发现没有公共前缀，则返回空字符串</span><br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> ans;<span class="hljs-comment">//返回最终结果</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>里氏代换原则</title>
    <link href="/2022/10/28/%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    <url>/2022/10/28/%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h3 id="OO-中的继承性的思考和说明"><a href="#OO-中的继承性的思考和说明" class="headerlink" title="OO 中的继承性的思考和说明"></a>OO 中的继承性的思考和说明</h3><ol><li><p>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有 的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</p></li><li><p><strong>继承在给程序设计带来便利的同时，也带来了弊端</strong>。比如使用继承会给程序带来<strong>侵入性</strong>，程序的可移植性降低， 增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且 父类修改后，所有涉及到子类的功能都有可能产生故障</p></li><li><p>问题提出：<strong>在编程中，如何正确的使用继承</strong>? =&gt; <strong>里氏替换</strong>原则</p></li></ol><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>   1.里氏替换原则(Liskov Substitution Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的。</p><ol start="2"><li><p>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都 代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。<strong>换句话说，所有引用基类的地 方必须能透明地使用其子类的对象</strong>。</p><p>3.在使用继承时，遵循里氏替换原则，在<strong>子类中尽量不要重写父类的方法</strong></p></li><li><p>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过<strong>聚合，组合，依赖 来 解决问题</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.principle.liskov;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Liskov</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + a.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<br>System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span> + a.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));<br><br>System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);<br><span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + b.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<span class="hljs-comment">//这里本意是求出11-3</span><br>System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span> + b.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));<span class="hljs-comment">// 1-8</span><br>System.out.println(<span class="hljs-string">&quot;11+3+9=&quot;</span> + b.func2(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<br><br><br><br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">// A类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-comment">// 返回两个数的差</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br><span class="hljs-keyword">return</span> num1 - num2;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// B类继承了A</span><br><span class="hljs-comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-comment">//这里，重写了A类的方法, 可能是无意识</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">return</span> func1(a, b) + <span class="hljs-number">9</span>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错 误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候</li><li>通用的做法是：<strong>原来的父类和子类都继承一个更通俗的基类</strong>，原有的继承关系去掉，采用<strong>依赖，聚合，组合</strong>等 关系代替.</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.principle.liskov.improve;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Liskov</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + a.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<br>System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span> + a.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));<br><br>System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);<br><span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br><span class="hljs-comment">//因为B类不再继承A类，因此调用者，不会再func1是求减法</span><br><span class="hljs-comment">//调用完成的功能就会很明确</span><br>System.out.println(<span class="hljs-string">&quot;11+3=&quot;</span> + b.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<span class="hljs-comment">//这里本意是求出11+3</span><br>System.out.println(<span class="hljs-string">&quot;1+8=&quot;</span> + b.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));<span class="hljs-comment">// 1+8</span><br>System.out.println(<span class="hljs-string">&quot;11+3+9=&quot;</span> + b.func2(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<br><br><br><span class="hljs-comment">//使用组合仍然可以使用到A类相关方法</span><br>System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + b.func3(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<span class="hljs-comment">// 这里本意是求出11-3</span><br><br><br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//创建一个更加基础的基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-comment">//把更加基础的方法和成员写到Base类</span><br>&#125;<br><br><span class="hljs-comment">// A类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-comment">// 返回两个数的差</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br><span class="hljs-keyword">return</span> num1 - num2;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// B类继承了A</span><br><span class="hljs-comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-comment">//如果B需要使用A类的方法,使用组合关系</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br><br><span class="hljs-comment">//这里，重写了A类的方法, 可能是无意识</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">return</span> func1(a, b) + <span class="hljs-number">9</span>;<br>&#125;<br><br><span class="hljs-comment">//我们仍然想使用A的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func3</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a.func1(a, b);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><p>​        这篇博客是我在B站看韩顺平老师设计模式的课时的笔记，记录一下，防止忘记，也希望能帮助各位朋友。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2022/10/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/10/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h4><p>快速排序（Quicksort）是对<strong>冒泡排序</strong>的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两 部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排 序，<strong>整个排序过程可以递归进行</strong>，以此达到整个数据变成有序序列</p><p>示意图：</p><p><img src="https://raw.githubusercontent.com/chaozuoxitong123/tuchuang/main/img202210281042247.png" alt="image-20221001205813931"></p><p><img src="https://raw.githubusercontent.com/chaozuoxitong123/tuchuang/main/img202210281042696.png" alt="image-20221001205830230"></p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>要求: 对 [-9,78,0,23,-567,70] 进行从小到大的排序，要求使用快速排序法。【测试 8w 和 800w】</p><p> 说明[验证分析]:</p><blockquote><ol><li>如果取消左右递归，结果是 -9 -567 0 23 78 70</li><li>如果取消右递归,结果是 -567 -9 0 23 78 70</li><li>如果取消左递归,结果是 -9 -567 0 23 70 78</li></ol></blockquote><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.atguigu.sort;<br><br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// int[] arr = &#123;-9,78,0,23,-567,70, -1,900, 4561&#125;;</span><br><br><span class="hljs-comment">// 测试快排的执行速度</span><br><span class="hljs-comment">// 创建要给80000个的随机的数组</span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">8000000</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8000000</span>; i++) &#123;<br>arr[i] = (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">8000000</span>); <span class="hljs-comment">// 生成一个[0, 8000000) 数</span><br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;排序前&quot;</span>);<br><span class="hljs-type">Date</span> <span class="hljs-variable">data1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">simpleDateFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">date1Str</span> <span class="hljs-operator">=</span> simpleDateFormat.format(data1);<br>System.out.println(<span class="hljs-string">&quot;排序前的时间是=&quot;</span> + date1Str);<br><br>quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br><br><span class="hljs-type">Date</span> <span class="hljs-variable">data2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">date2Str</span> <span class="hljs-operator">=</span> simpleDateFormat.format(data2);<br>System.out.println(<span class="hljs-string">&quot;排序后的时间是=&quot;</span> + date2Str);<br><span class="hljs-comment">// System.out.println(&quot;arr=&quot; + Arrays.toString(arr));</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> left;<span class="hljs-comment">// 左下标</span><br><span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> right;<span class="hljs-comment">// 右下标</span><br><span class="hljs-comment">// privot 中轴值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[(left + right) / <span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 临时变量，作为交换时使用</span><br><span class="hljs-comment">// while循环的目的是让比pivot值小放到左边</span><br><span class="hljs-comment">// 比pivot值大放到右边</span><br><span class="hljs-keyword">while</span> (l &lt; r) &#123;<br><span class="hljs-comment">// 在pivot的左边一直找，找到大于等于pivot值，才退出</span><br><span class="hljs-keyword">while</span> (arr[l] &lt; pivot) &#123;<br>l += <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 在pivot的右边一直找，找到小于等于pivot值，才退出</span><br><span class="hljs-keyword">while</span> (arr[r] &gt; pivot) &#123;<br>r -= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是</span><br><span class="hljs-comment">// 小于等于pivot值，右边全部是大于等于pivot值</span><br><span class="hljs-keyword">if</span> (l &gt;= r) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 交换</span><br>temp = arr[l];<br>arr[l] = arr[r];<br>arr[r] = temp;<br><br><span class="hljs-comment">// 如果交换完后，发现这个arr[l]==pivot值相等 r--,前移</span><br><span class="hljs-keyword">if</span> (arr[l] == pivot) &#123;<br>r -= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 如果交换完后，发现这个arr[r]==pivot值相等 l++,后移</span><br><span class="hljs-keyword">if</span> (arr[r] == pivot) &#123;<br>l += <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 如果l == r,必须l++,r--,否则会出现栈溢出</span><br><span class="hljs-keyword">if</span> (l == r) &#123;<br>l += <span class="hljs-number">1</span>;<br>r -= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 向左递归</span><br><span class="hljs-keyword">if</span> (left &lt; r) &#123;<br>quickSort(arr, left, r);<br>&#125;<br><span class="hljs-keyword">if</span> (right &gt; l) &#123;<br>quickSort(arr, l, right);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行截图：</p><p><img src="https://raw.githubusercontent.com/chaozuoxitong123/tuchuang/main/img202210281042394.png" alt="image-20221001210112911"></p><p>从运行结果来看，快速排序算法速度较快。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树的遍历</title>
    <link href="/2022/10/27/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2022/10/27/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h4 id="二叉树的遍历应用实例"><a href="#二叉树的遍历应用实例" class="headerlink" title="二叉树的遍历应用实例"></a>二叉树的遍历应用实例</h4><h5 id="前序遍历，中序遍历，后序遍历步骤"><a href="#前序遍历，中序遍历，后序遍历步骤" class="headerlink" title="前序遍历，中序遍历，后序遍历步骤"></a>前序遍历，中序遍历，后序遍历步骤</h5><h6 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h6><blockquote><p>1.先输出当前节点</p><p>2.如果当前节点的左子节点不为空，则递归前序遍历</p><p>3.如果当前节点的右子节点不为空，则递归前序遍历</p></blockquote><h6 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h6><blockquote><p>1.如果当前节点的左子节点不为空，则递归中序遍历</p><p>2.输出当前节点</p><p>3.如果当前节点的右子节点不为空，则递归中序遍历</p></blockquote><h6 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h6><blockquote><p>1.如果当前节点的左子节点不为空，则递归后序遍历</p><p>2.如果当前节点的右子节点不为空，则递归后序遍历</p><p>3.输出当前节点</p></blockquote><p>代码实现：</p><p>先创建HeroNode 结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroNode</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> no;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> HeroNode left; <span class="hljs-comment">//默认null</span><br><span class="hljs-keyword">private</span> HeroNode right; <span class="hljs-comment">//默认null</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HeroNode</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name)</span> &#123;<br><span class="hljs-built_in">this</span>.no = no;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> no;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNo</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br><span class="hljs-built_in">this</span>.no = no;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">getLeft</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLeft</span><span class="hljs-params">(HeroNode left)</span> &#123;<br><span class="hljs-built_in">this</span>.left = left;<br>&#125;<br><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">getRight</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> right;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRight</span><span class="hljs-params">(HeroNode right)</span> &#123;<br><span class="hljs-built_in">this</span>.right = right;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HeroNode [no=&quot;</span> + no + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//编写前序遍历的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//先输出父结点</span><br><span class="hljs-comment">//递归向左子树前序遍历</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.left.preOrder();<br>&#125;<br><span class="hljs-comment">//递归向右子树前序遍历</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.right.preOrder();<br>&#125;<br>&#125;<br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-comment">//递归向左子树中序遍历</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.left.infixOrder();<br>&#125;<br><span class="hljs-comment">//输出父结点</span><br>System.out.println(<span class="hljs-built_in">this</span>);<br><span class="hljs-comment">//递归向右子树中序遍历</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.right.infixOrder();<br>&#125;<br>&#125;<br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.left.postOrder();<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.right.postOrder();<br>&#125;<br>System.out.println(<span class="hljs-built_in">this</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义BinaryTree 二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span> &#123;<br><span class="hljs-keyword">private</span> HeroNode root;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoot</span><span class="hljs-params">(HeroNode root)</span> &#123;<br><span class="hljs-built_in">this</span>.root = root;<br>&#125;<br><br><span class="hljs-comment">//前序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.root.preOrder();<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;二叉树为空，无法遍历&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.root.infixOrder();<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;二叉树为空，无法遍历&quot;</span>);<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.root.postOrder();<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;二叉树为空，无法遍历&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.tree;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTreeDemo</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//先需要创建一颗二叉树</span><br><span class="hljs-type">BinaryTree</span> <span class="hljs-variable">binaryTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryTree</span>();<br><span class="hljs-comment">//创建需要的结点</span><br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;宋江&quot;</span>);<br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;吴用&quot;</span>);<br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">node3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;卢俊义&quot;</span>);<br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">node4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;林冲&quot;</span>);<br><span class="hljs-type">HeroNode</span> <span class="hljs-variable">node5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;关胜&quot;</span>);<br><br><span class="hljs-comment">//说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span><br>root.setLeft(node2);<br>root.setRight(node3);<br>node3.setRight(node4);<br>node3.setLeft(node5);<br>binaryTree.setRoot(root);<br><br><span class="hljs-comment">//测试</span><br>        System.out.println(<span class="hljs-string">&quot;前序遍历&quot;</span>); <br>        binaryTree.preOrder();<span class="hljs-comment">// 1,2,3,5,4</span><br><br><span class="hljs-comment">//测试 </span><br>System.out.println(<span class="hljs-string">&quot;中序遍历&quot;</span>);<br>binaryTree.infixOrder(); <span class="hljs-comment">// 2,1,5,3,4</span><br><br>        System.out.println(<span class="hljs-string">&quot;后序遍历&quot;</span>);<br>        binaryTree.postOrder(); <span class="hljs-comment">// 2,5,4,3,1</span><br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>代码运行结果：</p><p><img src="https://raw.githubusercontent.com/chaozuoxitong123/tuchuang/main/img202210271407280.png" alt="image-20220923192800153"></p><p>这篇博客是我在B站看韩顺平老师数据结构和算法的课时的笔记，记录一下，防止忘记，也希望能帮助各位朋友。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>罗马数字转整数</title>
    <link href="/2022/10/27/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <url>/2022/10/27/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">字符          数值<br><span class="hljs-built_in">I</span>             <span class="hljs-number">1</span><br><span class="hljs-variable">V</span>             <span class="hljs-number">5</span><br><span class="hljs-variable">X</span>             <span class="hljs-number">10</span><br><span class="hljs-variable">L</span>             <span class="hljs-number">50</span><br><span class="hljs-built_in">C</span>             <span class="hljs-number">100</span><br><span class="hljs-built_in">D</span>             <span class="hljs-number">500</span><br><span class="hljs-variable">M</span>             <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 1 。<code>12</code> 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 <code>27</code> 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><blockquote><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul></blockquote><p>给定一个罗马数字，将其转换成整数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;III&quot;</span><br><span class="hljs-section">输出: 3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;IV&quot;</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;IX&quot;</span><br><span class="hljs-section">输出: 9</span><br></code></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;LVIII&quot;</span><br><span class="hljs-section">输出: 58</span><br><span class="hljs-section">解释: L = 50, V= 5, III = 3.</span><br></code></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;MCMXCIV&quot;</span><br><span class="hljs-section">输出: 1994</span><br><span class="hljs-section">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></code></pre></td></tr></table></figure><blockquote><ul><li><code>1 &lt;= s.length &lt;= 15</code></li><li><code>s</code> 仅含字符 <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code></li><li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li><li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li><li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li></ul></blockquote><p>思路分析：由题意知，当小值在大值左边时，做减法运算；当小值在大值右边时，做加法运算。所以在编码时，可以比较当前位与后面一位的大小关系，前面的元素比后面的元素小，进行减法运算，减去当前位的值；前面的元素比后面的元素大，进行加法运算，加上当前位的值。最后一位必定做加法运算。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T13</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 测试一把</span><br><span class="hljs-type">Solution</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> solution.Numbers(<span class="hljs-string">&quot;LVIII&quot;</span>);<br>System.out.println(flag);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Numbers</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//用来计算最终的结果</span><br><span class="hljs-type">int</span> <span class="hljs-variable">preNum</span> <span class="hljs-operator">=</span> getNumbers(s.charAt(<span class="hljs-number">0</span>));<span class="hljs-comment">//定义一个指针，指向字符串的第一个字符，也就是下标为0的位置</span><br><span class="hljs-comment">//开始遍历字符串，把前面一个字符和后面一个字符进行比较</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; s.length();i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> getNumbers(s.charAt(i));<span class="hljs-comment">//定义一个指针num,指向后面的一个元素</span><br><span class="hljs-keyword">if</span>(preNum &lt; num) &#123;<br><span class="hljs-comment">//前面的元素比后面的元素小，进行减法运算</span><br>sum -= preNum;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//前面的元素比后面的元素大，进行加法运算</span><br>sum += preNum;<br>&#125;<br>preNum = num;<span class="hljs-comment">//指针后移</span><br>&#125;<br>sum += preNum;<span class="hljs-comment">//最后一个元素必定进行加法运算</span><br><span class="hljs-keyword">return</span> sum;<span class="hljs-comment">//计算结束，返回结果</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumbers</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br><span class="hljs-keyword">switch</span> (ch) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;I&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;V&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">500</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行截图：</p><p><img src="https://raw.githubusercontent.com/chaozuoxitong123/tuchuang/main/img202210271349680.png" alt="image-20221011212035568"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/26/hello-world/"/>
    <url>/2022/10/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
